using NAI.Projekt.KNN_ConsoleApp_s24759.Structures;
using Spectre.Console;

namespace NAI.Projekt.KNN_ConsoleApp_s24759.Algorithms;

public class KNN
{
    public int Kvalue { get; private set; }
    public List<KnnVector<double>> TrainSet { get; private set; }
    public List<KnnVector<double>> TestSet { get; private set; }
    
    public bool IsModelReady => TrainSet.Count > 0;
    
    private static Style[] decisiveAttributeAdditionalStyles = new []
    {
        Style.Parse("green"),
        Style.Parse("blue"),
        Style.Parse("magenta"),
        Style.Parse("cyan"),
        Style.Parse("magenta3_1")
    };
                
    private static Style[] columnStyles = new []
    {
        Style.Parse("aqua"),
        Style.Parse("hotpink3"),
        Style.Parse("teal"),
        Style.Parse("mediumpurple4"),
        Style.Parse("darkorange"),
    };

    public KNN(int kValue, List<KnnVector<double>> trainSet, List<KnnVector<double>> testSet)
    {
        Kvalue = kValue;
        TrainSet = trainSet;
        TestSet = testSet;
        CheckForInputDataValidity();
    }

    private void CheckForInputDataValidity()
    {
        // Sprawdzamy poprawność danych wejściowych

        // Sprawdzenie dla K
        if (Kvalue < 1)
            throw new Exception("K musi być większe od 0");
        if (Kvalue > TrainSet.Count)
            throw new Exception("K nie może być większe od liczby wektorów uczących");

        // Sprawdzenie dla danych uczących
        if (TrainSet.Count < 1)
            throw new Exception("Liczba wektorów uczących musi być większa od 0");

        var numberOfPointsInFirstVector = TrainSet[0].NumberOfPoints;
        if (TrainSet.Any(vector => vector.NumberOfPoints != numberOfPointsInFirstVector))
            throw new Exception("Liczba punktów we wszystkich wektorach musi być taka sama");

        // Sprawdzenie dla danych testowych
        if (TestSet.Count == 0) return;
        {
            if (TestSet.Any(vector => vector.NumberOfPoints != numberOfPointsInFirstVector))
                throw new Exception("Liczba punktów we wszystkich wektorach musi być taka sama");

            if (TestSet.Any(vector => vector.UnderlyingType != TrainSet[0].UnderlyingType))
                throw new Exception("Typy danych we wszystkich wektorach muszą być takie same");
        }

    }
    
    public void ShowKnnModelLive()
    {
        var table = new Table().Centered()
            .Border(TableBorder.Rounded).BorderStyle(Style.Parse("red")).HeavyBorder()
            .Title(new TableTitle("Dane treningowe", new Style(Color.Yellow)));

        AnsiConsole.Live(table)
            .AutoClear(false)
            .Start(ctx =>
            {
                var inputData = TrainSet;
                var innerPoints = inputData.First().InnerPoints;

                for (var i = 0; i < innerPoints.Count; i++)
                {
                    var columnNameMarkup = new Markup(((VectorPointsAutoGeneratedNames) i).ToString(), columnStyles[i]);
                    table.AddColumn(new TableColumn(columnNameMarkup).Centered()).Centered();
                    ctx.Refresh();
                    Thread.Sleep(500);
                }

                table.AddColumn("Atrybut decyzyjny");
                ctx.Refresh();
                Thread.Sleep(600);

                var prevDecisiveAttribute = "";
                var currentDecisiveAttributeStyle = new Style(Color.Green);
              
                var currentDecisiveAttributeStyleIndex = -1;
                var indexOfColumn = -1;

                foreach (var vector in inputData)
                {
                    var row = vector.InnerPoints.Select(point =>
                    {
                        indexOfColumn++;
                        var style = columnStyles[indexOfColumn];
                        return new Markup($"{point.ToString()}", style).Centered();
                    }).ToList();
                    indexOfColumn = -1;
                    
                    if (prevDecisiveAttribute != vector.DecisiveAttributeName)
                    {
                        currentDecisiveAttributeStyleIndex++;
                        currentDecisiveAttributeStyle = decisiveAttributeAdditionalStyles[currentDecisiveAttributeStyleIndex];
                        prevDecisiveAttribute = vector.DecisiveAttributeName;
                    }
                    row.Add(new Markup(vector.DecisiveAttributeName, currentDecisiveAttributeStyle).Centered());
                    table.AddRow(row.ToArray());
                    ctx.Refresh();
                    Thread.Sleep(50);
                }
            });
    }
}

